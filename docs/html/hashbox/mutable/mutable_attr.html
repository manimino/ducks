<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hashbox.mutable.mutable_attr API documentation</title>
<meta name="description" content="MutableAttrIndex contains a dict of set of object IDs …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hashbox.mutable.mutable_attr</code></h1>
</header>
<section id="section-intro">
<p>MutableAttrIndex contains a dict of set of object IDs.</p>
<p>Well, ok, it's a little more complicated than that. We don't always
use sets, because sets are REALLY inefficient for small collections.</p>
<p>Bytes per integer, by collection size</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>10</th>
<th>50</th>
<th>100</th>
<th>1000</th>
<th>10000</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python tuple</td>
<td>56.8</td>
<td>14.0</td>
<td>9.3</td>
<td>8.6</td>
<td>32.2</td>
<td>39.7</td>
</tr>
<tr>
<td>Python set</td>
<td>235.6</td>
<td>82.1</td>
<td>46.0</td>
<td>84.5</td>
<td>57.2</td>
<td>84.6</td>
</tr>
<tr>
<td>cykhash set</td>
<td>168.5</td>
<td>26.5</td>
<td>23.6</td>
<td>22.3</td>
<td>17.0</td>
<td>13.6</td>
</tr>
<tr>
<td>numpy array</td>
<td>169.6</td>
<td>23.4</td>
<td>11.1</td>
<td>9.6</td>
<td>8.2</td>
<td>8.0</td>
</tr>
</tbody>
</table>
<p>Those numbers were measured by examining process-level memory usage before and after
collections were created, so there's a little +/- there.
For example, a set containing a SINGLE INTEGER is actually 248 bytes.
248.
Bytes.
To store a single 8-byte integer.</p>
<p>Seriously, you can check it yourself.</p>
<pre><code>from pympler.asizeof import asizeof
asizeof(set([1]))
# Yep, says 248. Yes, that's actually bytes and not bits.
</code></pre>
<p>Imagine if all our attribute values were unique, and we're storing a dict of millions of sets of size 1.
Ouch. Yeah, let's not do that. In fact, let's not use Python set() at all! We're only storing numbers, so a typed set
will be much more efficient. The cykhash sets are just perfect for this. They're about as fast as Python sets,
and around 1/4 the RAM.</p>
<p>For smaller collections, below 100 numbers, cykhash is a bit inefficient, so we use tuples there instead.
While they are immutable, it's not a big deal to discard a tuple of size 100 and make another one.</p>
<p>And for collections of size 1&hellip; we just store the number.</p>
<p>Using different collection sizes like this helps keep our memory usage from going too crazy.
A naive implementation would spend a gigabyte of RAM indexing a few million integers. While this
adds a bit of code complexity, it's a pretty great trade. Just gotta test it for each collection size, and we do.</p>
<p>For the FrozenHashBox, we use numpy arrays, because they're the best. As long as you don't need to add or remove
objects, anyway.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
MutableAttrIndex contains a dict of set of object IDs.

Well, ok, it&#39;s a little more complicated than that. We don&#39;t always
use sets, because sets are REALLY inefficient for small collections.

Bytes per integer, by collection size

|              | 1     | 10   | 50   | 100  | 1000 | 10000  |
|--------------|-------|------|------|------|------|--------|
| Python tuple | 56.8  | 14.0 | 9.3  | 8.6  | 32.2 | 39.7   |
| Python set   | 235.6 | 82.1 | 46.0 | 84.5 | 57.2 | 84.6   |
| cykhash set  | 168.5 | 26.5 | 23.6 | 22.3 | 17.0 | 13.6   |
| numpy array  | 169.6 | 23.4 | 11.1 | 9.6  | 8.2  | 8.0    |

Those numbers were measured by examining process-level memory usage before and after
collections were created, so there&#39;s a little +/- there.
For example, a set containing a SINGLE INTEGER is actually 248 bytes.
248.
Bytes.
To store a single 8-byte integer.

Seriously, you can check it yourself.
```
from pympler.asizeof import asizeof
asizeof(set([1]))
# Yep, says 248. Yes, that&#39;s actually bytes and not bits.
```

Imagine if all our attribute values were unique, and we&#39;re storing a dict of millions of sets of size 1.
Ouch. Yeah, let&#39;s not do that. In fact, let&#39;s not use Python set() at all! We&#39;re only storing numbers, so a typed set
will be much more efficient. The cykhash sets are just perfect for this. They&#39;re about as fast as Python sets,
and around 1/4 the RAM.

For smaller collections, below 100 numbers, cykhash is a bit inefficient, so we use tuples there instead.
While they are immutable, it&#39;s not a big deal to discard a tuple of size 100 and make another one.

And for collections of size 1... we just store the number.

Using different collection sizes like this helps keep our memory usage from going too crazy.
A naive implementation would spend a gigabyte of RAM indexing a few million integers. While this
adds a bit of code complexity, it&#39;s a pretty great trade. Just gotta test it for each collection size, and we do.

For the FrozenHashBox, we use numpy arrays, because they&#39;re the best. As long as you don&#39;t need to add or remove
objects, anyway.
&#34;&#34;&#34;

from typing import Callable, Union, Dict, Any, Iterable, Optional

from cykhash import Int64Set

from hashbox.constants import TUPLE_SIZE_MAX, SET_SIZE_MIN
from hashbox.init_helpers import compute_mutable_dict
from hashbox.utils import get_attribute


class MutableAttrIndex:
    &#34;&#34;&#34;
    Stores the possible values of this attribute in a collection of buckets.
    Several values may be allocated to the same bucket for space efficiency reasons.
    &#34;&#34;&#34;

    def __init__(
        self,
        attr: Union[Callable, str],
        obj_map: Dict[int, Any],
        objs: Optional[Iterable[Any]] = None,
    ):
        self.attr = attr
        self.obj_map = obj_map
        if objs:
            self.d = compute_mutable_dict(objs, attr)
        else:
            self.d = dict()

    def get_obj_ids(self, val: Any) -&gt; Int64Set:
        &#34;&#34;&#34;Get the object IDs associated with this value as an Int64Set.&#34;&#34;&#34;
        ids = self.d.get(val, Int64Set())
        if isinstance(ids, tuple):
            return Int64Set(ids)
        elif isinstance(ids, Int64Set):
            return ids
        else:
            return Int64Set([ids])

    def add(self, ptr: int, obj: Any):
        &#34;&#34;&#34;Add an object if it has this attribute.&#34;&#34;&#34;
        val, success = get_attribute(obj, self.attr)
        if not success:
            return
        if val in self.d:
            if isinstance(self.d[val], tuple):
                if len(self.d[val]) == TUPLE_SIZE_MAX:
                    self.d[val] = Int64Set(self.d[val])
                    self.d[val].add(ptr)
                else:
                    self.d[val] = tuple(list(self.d[val]) + [ptr])
            elif isinstance(self.d[val], Int64Set):
                self.d[val].add(ptr)
            else:
                self.d[val] = (self.d[val], ptr)
        else:
            self.d[val] = ptr

    def remove(self, ptr: int, obj: Any):
        &#34;&#34;&#34;Remove a single object from the index. ptr is already known to be in the index.&#34;&#34;&#34;
        val, success = get_attribute(obj, self.attr)
        if not success:
            return
        obj_ids = self.d[val]
        if isinstance(obj_ids, tuple) or isinstance(obj_ids, Int64Set):
            if isinstance(obj_ids, tuple):
                self.d[val] = tuple(obj_id for obj_id in obj_ids if obj_id != ptr)
                if len(self.d[val]) == 1:
                    self.d[val] = self.d[val][0]
            else:
                self.d[val].remove(ptr)
                if len(self.d[val]) &lt; SET_SIZE_MIN:
                    self.d[val] = tuple(self.d[val])
        else:
            del self.d[val]

    def get_all_ids(self):
        &#34;&#34;&#34;Get the ID of every object that has this attribute.
        Called when matching or excluding {attr: hashindex.ANY}.&#34;&#34;&#34;
        obj_ids = Int64Set()
        for key, val in self.d.items():
            if isinstance(val, tuple):
                obj_ids = obj_ids.union(Int64Set(val))
            elif isinstance(val, Int64Set):
                obj_ids = obj_ids.union(val)
            else:
                obj_ids.add(val)
        return obj_ids

    def get_values(self):
        &#34;&#34;&#34;Get unique values we have objects for.&#34;&#34;&#34;
        return set(self.d.keys())

    def __len__(self):
        tot = 0
        for key, val in self.d.items():
            if isinstance(val, tuple) or isinstance(val, Int64Set):
                tot += len(val)
            else:
                tot += 1
        return tot</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hashbox.mutable.mutable_attr.MutableAttrIndex"><code class="flex name class">
<span>class <span class="ident">MutableAttrIndex</span></span>
<span>(</span><span>attr: Union[str, Callable], obj_map: Dict[int, Any], objs: Optional[Iterable[Any]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the possible values of this attribute in a collection of buckets.
Several values may be allocated to the same bucket for space efficiency reasons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MutableAttrIndex:
    &#34;&#34;&#34;
    Stores the possible values of this attribute in a collection of buckets.
    Several values may be allocated to the same bucket for space efficiency reasons.
    &#34;&#34;&#34;

    def __init__(
        self,
        attr: Union[Callable, str],
        obj_map: Dict[int, Any],
        objs: Optional[Iterable[Any]] = None,
    ):
        self.attr = attr
        self.obj_map = obj_map
        if objs:
            self.d = compute_mutable_dict(objs, attr)
        else:
            self.d = dict()

    def get_obj_ids(self, val: Any) -&gt; Int64Set:
        &#34;&#34;&#34;Get the object IDs associated with this value as an Int64Set.&#34;&#34;&#34;
        ids = self.d.get(val, Int64Set())
        if isinstance(ids, tuple):
            return Int64Set(ids)
        elif isinstance(ids, Int64Set):
            return ids
        else:
            return Int64Set([ids])

    def add(self, ptr: int, obj: Any):
        &#34;&#34;&#34;Add an object if it has this attribute.&#34;&#34;&#34;
        val, success = get_attribute(obj, self.attr)
        if not success:
            return
        if val in self.d:
            if isinstance(self.d[val], tuple):
                if len(self.d[val]) == TUPLE_SIZE_MAX:
                    self.d[val] = Int64Set(self.d[val])
                    self.d[val].add(ptr)
                else:
                    self.d[val] = tuple(list(self.d[val]) + [ptr])
            elif isinstance(self.d[val], Int64Set):
                self.d[val].add(ptr)
            else:
                self.d[val] = (self.d[val], ptr)
        else:
            self.d[val] = ptr

    def remove(self, ptr: int, obj: Any):
        &#34;&#34;&#34;Remove a single object from the index. ptr is already known to be in the index.&#34;&#34;&#34;
        val, success = get_attribute(obj, self.attr)
        if not success:
            return
        obj_ids = self.d[val]
        if isinstance(obj_ids, tuple) or isinstance(obj_ids, Int64Set):
            if isinstance(obj_ids, tuple):
                self.d[val] = tuple(obj_id for obj_id in obj_ids if obj_id != ptr)
                if len(self.d[val]) == 1:
                    self.d[val] = self.d[val][0]
            else:
                self.d[val].remove(ptr)
                if len(self.d[val]) &lt; SET_SIZE_MIN:
                    self.d[val] = tuple(self.d[val])
        else:
            del self.d[val]

    def get_all_ids(self):
        &#34;&#34;&#34;Get the ID of every object that has this attribute.
        Called when matching or excluding {attr: hashindex.ANY}.&#34;&#34;&#34;
        obj_ids = Int64Set()
        for key, val in self.d.items():
            if isinstance(val, tuple):
                obj_ids = obj_ids.union(Int64Set(val))
            elif isinstance(val, Int64Set):
                obj_ids = obj_ids.union(val)
            else:
                obj_ids.add(val)
        return obj_ids

    def get_values(self):
        &#34;&#34;&#34;Get unique values we have objects for.&#34;&#34;&#34;
        return set(self.d.keys())

    def __len__(self):
        tot = 0
        for key, val in self.d.items():
            if isinstance(val, tuple) or isinstance(val, Int64Set):
                tot += len(val)
            else:
                tot += 1
        return tot</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="hashbox.mutable.mutable_attr.MutableAttrIndex.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, ptr: int, obj: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an object if it has this attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, ptr: int, obj: Any):
    &#34;&#34;&#34;Add an object if it has this attribute.&#34;&#34;&#34;
    val, success = get_attribute(obj, self.attr)
    if not success:
        return
    if val in self.d:
        if isinstance(self.d[val], tuple):
            if len(self.d[val]) == TUPLE_SIZE_MAX:
                self.d[val] = Int64Set(self.d[val])
                self.d[val].add(ptr)
            else:
                self.d[val] = tuple(list(self.d[val]) + [ptr])
        elif isinstance(self.d[val], Int64Set):
            self.d[val].add(ptr)
        else:
            self.d[val] = (self.d[val], ptr)
    else:
        self.d[val] = ptr</code></pre>
</details>
</dd>
<dt id="hashbox.mutable.mutable_attr.MutableAttrIndex.get_all_ids"><code class="name flex">
<span>def <span class="ident">get_all_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ID of every object that has this attribute.
Called when matching or excluding {attr: hashindex.ANY}.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_ids(self):
    &#34;&#34;&#34;Get the ID of every object that has this attribute.
    Called when matching or excluding {attr: hashindex.ANY}.&#34;&#34;&#34;
    obj_ids = Int64Set()
    for key, val in self.d.items():
        if isinstance(val, tuple):
            obj_ids = obj_ids.union(Int64Set(val))
        elif isinstance(val, Int64Set):
            obj_ids = obj_ids.union(val)
        else:
            obj_ids.add(val)
    return obj_ids</code></pre>
</details>
</dd>
<dt id="hashbox.mutable.mutable_attr.MutableAttrIndex.get_obj_ids"><code class="name flex">
<span>def <span class="ident">get_obj_ids</span></span>(<span>self, val: Any) ‑> cykhash.khashsets.Int64Set</span>
</code></dt>
<dd>
<div class="desc"><p>Get the object IDs associated with this value as an Int64Set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_obj_ids(self, val: Any) -&gt; Int64Set:
    &#34;&#34;&#34;Get the object IDs associated with this value as an Int64Set.&#34;&#34;&#34;
    ids = self.d.get(val, Int64Set())
    if isinstance(ids, tuple):
        return Int64Set(ids)
    elif isinstance(ids, Int64Set):
        return ids
    else:
        return Int64Set([ids])</code></pre>
</details>
</dd>
<dt id="hashbox.mutable.mutable_attr.MutableAttrIndex.get_values"><code class="name flex">
<span>def <span class="ident">get_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get unique values we have objects for.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values(self):
    &#34;&#34;&#34;Get unique values we have objects for.&#34;&#34;&#34;
    return set(self.d.keys())</code></pre>
</details>
</dd>
<dt id="hashbox.mutable.mutable_attr.MutableAttrIndex.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, ptr: int, obj: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a single object from the index. ptr is already known to be in the index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, ptr: int, obj: Any):
    &#34;&#34;&#34;Remove a single object from the index. ptr is already known to be in the index.&#34;&#34;&#34;
    val, success = get_attribute(obj, self.attr)
    if not success:
        return
    obj_ids = self.d[val]
    if isinstance(obj_ids, tuple) or isinstance(obj_ids, Int64Set):
        if isinstance(obj_ids, tuple):
            self.d[val] = tuple(obj_id for obj_id in obj_ids if obj_id != ptr)
            if len(self.d[val]) == 1:
                self.d[val] = self.d[val][0]
        else:
            self.d[val].remove(ptr)
            if len(self.d[val]) &lt; SET_SIZE_MIN:
                self.d[val] = tuple(self.d[val])
    else:
        del self.d[val]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hashbox.mutable" href="index.html">hashbox.mutable</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hashbox.mutable.mutable_attr.MutableAttrIndex" href="#hashbox.mutable.mutable_attr.MutableAttrIndex">MutableAttrIndex</a></code></h4>
<ul class="">
<li><code><a title="hashbox.mutable.mutable_attr.MutableAttrIndex.add" href="#hashbox.mutable.mutable_attr.MutableAttrIndex.add">add</a></code></li>
<li><code><a title="hashbox.mutable.mutable_attr.MutableAttrIndex.get_all_ids" href="#hashbox.mutable.mutable_attr.MutableAttrIndex.get_all_ids">get_all_ids</a></code></li>
<li><code><a title="hashbox.mutable.mutable_attr.MutableAttrIndex.get_obj_ids" href="#hashbox.mutable.mutable_attr.MutableAttrIndex.get_obj_ids">get_obj_ids</a></code></li>
<li><code><a title="hashbox.mutable.mutable_attr.MutableAttrIndex.get_values" href="#hashbox.mutable.mutable_attr.MutableAttrIndex.get_values">get_values</a></code></li>
<li><code><a title="hashbox.mutable.mutable_attr.MutableAttrIndex.remove" href="#hashbox.mutable.mutable_attr.MutableAttrIndex.remove">remove</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>